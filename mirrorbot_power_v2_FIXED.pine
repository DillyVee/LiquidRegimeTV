// @version=5
strategy("MirrorBot Power V2 — Bayesian + GARCH (Production)",
  shorttitle="MB-PwrV2",
  overlay=true,
  initial_capital=100000,
  default_qty_type=strategy.percent_of_equity,
  default_qty_value=100,
  commission_type=strategy.commission.percent,
  commission_value=0.075,
  slippage=1)

// ============================================================================
// POWER EDITION V2 - ALL NaN ISSUES FIXED + REGIME SWITCHING BUG FIXED
// ============================================================================
// FIXES APPLIED:
// 1. vol_cluster NaN sanitization
// 2. All feature NaN sanitization before likelihood calc
// 3. Safe Gaussian likelihood with NaN handling
// 4. Fixed prev_map logic (regime switching was broken)
// 5. GARCH init NaN protection
// 6. vol_of_vol early-bar NaN protection
// 7. CRITICAL: Fixed CUSUM force switch bug (regime_dur >= 1 removed)
// 8. CRITICAL: Replaced alertcondition() with alert() for strategies
// 9. Added Trading Mode toggle (Long Only / Short Only / Both)
// ============================================================================

// ============================================================================
// USER INPUTS
// ============================================================================
group_vol = "Volatility & GARCH"
garch_omega = input.float(1e-6, "GARCH ω (omega)", group=group_vol, step=1e-6)
garch_alpha = input.float(0.12, "GARCH α (alpha)", group=group_vol, step=0.01)
garch_beta = input.float(0.82, "GARCH β (beta)", group=group_vol, step=0.01)
garch_init_lb = input.int(50, "GARCH init lookback", group=group_vol, minval=10)

group_cusum = "CUSUM / Change-point"
cusum_k_mult = input.float(3.0, "CUSUM threshold mult (k)", group=group_cusum)
cusum_drift_mult = input.float(0.15, "CUSUM drift mult", group=group_cusum)
cusum_reset_on_detect = input.bool(true, "Reset CUSUM on detect", group=group_cusum)

group_bayes = "Bayesian Regime Filter"
inertia = input.float(0.90, "State Inertia (0-1)", group=group_bayes, step=0.01)
min_switch_duration = input.int(3, "Min Regime Duration (bars)", group=group_bayes, minval=1)
confidence_threshold = input.float(0.55, "Confidence Threshold", group=group_bayes, step=0.01)
uncertain_position_mult = input.float(0.35, "Position Mult in UNCERTAIN", group=group_bayes, step=0.01)

group_tune = "Auto-Tune (Safe)"
enable_auto_tune = input.bool(true, "Enable auto-tune", group=group_tune)
tune_aggressiveness = input.float(0.03, "Aggressiveness", group=group_tune, step=0.01)
tune_decay = input.float(0.98, "Decay (snap-back)", group=group_tune, step=0.001)

group_entries = "Entries & MirrorBot"
magic_rsi_period = input.int(9, "RSI period", group=group_entries, minval=2)
magic_rsi2_period = input.int(144, "RSI-of-RSI period", group=group_entries, minval=10)
long_entry_val = input.float(49.9, "Long Entry (RSI2)", group=group_entries)
long_tp_val = input.float(50.0, "Long TP (RSI2)", group=group_entries)
short_entry_val = input.float(50.1, "Short Entry (RSI2)", group=group_entries)
short_tp_val = input.float(50.0, "Short TP (RSI2)", group=group_entries)

group_risk = "Position Sizing"
base_size_pct = input.float(100.0, "Base position (% equity)", group=group_risk)
max_position_mult = input.float(1.5, "Max Regime Multiplier", group=group_risk)
min_position_mult = input.float(0.1, "Min Regime Multiplier", group=group_risk)

// Regime permissions
allow_bull = input.bool(true, "Allow BULL", group="Regime Permissions")
allow_bear = input.bool(true, "Allow BEAR", group="Regime Permissions")
allow_highv = input.bool(true, "Allow HIGH VOL", group="Regime Permissions")
allow_lowv = input.bool(true, "Allow LOW VOL", group="Regime Permissions")
allow_crisis = input.bool(false, "Allow CRISIS", group="Regime Permissions")

// Display
show_table = input.bool(true, "Show info table", group="Display")
show_bg = input.bool(true, "Show regime background", group="Display")

// ============================================================================
// BASIC FEATURES (NaN-SAFE)
// ============================================================================
src = hlc3
r = math.log(close / close[1])
r := na(r) ? 0.0 : r  // FIX: sanitize immediately

// RSI-of-RSI
rsi1 = ta.rsi(src, magic_rsi_period)
rsi2 = ta.rsi(rsi1, magic_rsi2_period)
rsi2 := na(rsi2) ? 50.0 : rsi2  // FIX: default to neutral

// Momentum & trend (NaN-SAFE)
mom_fast = ta.roc(close, 10)
mom_med = ta.roc(close, 20)
mom_slow = ta.roc(close, 60)
mom_fast := na(mom_fast) ? 0.0 : mom_fast
mom_med := na(mom_med) ? 0.0 : mom_med
mom_slow := na(mom_slow) ? 0.0 : mom_slow
mom_score = (mom_fast + mom_med + mom_slow) / 3.0

ema_fast = ta.ema(close, 20)
ema_slow = ta.ema(close, 50)
trend_alignment = (ema_fast - ema_slow) / ema_slow
trend_alignment := na(trend_alignment) ? 0.0 : trend_alignment  // FIX

// Volume (NaN-SAFE)
vol_ma = ta.sma(volume, 20)
volume_factor = na(vol_ma) or vol_ma == 0 ? 0.0 : math.log(volume / vol_ma)
volume_factor := na(volume_factor) ? 0.0 : volume_factor  // FIX

// Microstructure (NaN-SAFE)
range_exp = (high - low) / close
range_ma = ta.sma(range_exp, 20)
micro_sig = na(range_ma) or range_ma == 0 ? 0.0 : (range_exp / range_ma - 1.0)
micro_sig := na(micro_sig) ? 0.0 : micro_sig  // FIX

// Drawdown (NaN-SAFE)
var float running_max = na
running_max := na(running_max) ? close : math.max(running_max, close)
drawdown = (close - running_max) / running_max
drawdown := na(drawdown) ? 0.0 : drawdown  // FIX

// ============================================================================
// GARCH(1,1) - NaN-SAFE INIT
// ============================================================================
var float cond_var = na

// FIX #5: GARCH init with proper NaN handling
init_var = ta.variance(r, garch_init_lb)
if na(cond_var)
    // Use init_var if valid, else use conservative default
    cond_var := na(init_var) or init_var <= 0 ? 0.0004 : init_var  // 2% annual vol default

omega = garch_omega
alpha = garch_alpha
beta = garch_beta

// Ensure stationarity
if alpha + beta >= 0.999
    beta := 0.98 - alpha

// Recursive GARCH update (NaN-SAFE)
r2 = r * r
lag_r2 = nz(r2[1], 0.0)
lag_cond_var = nz(cond_var[1], 0.0004)
cond_var := nz(omega, 1e-6) + nz(alpha, 0.1) * lag_r2 + nz(beta, 0.85) * lag_cond_var
cond_var := math.max(cond_var, 1e-12)  // floor

garch_vol = math.sqrt(cond_var) * math.sqrt(252)
garch_vol := na(garch_vol) ? 0.20 : garch_vol  // FIX: default 20% annual

// Vol regime buckets
vol_low_th = input.float(0.10, "vol low threshold", group=group_vol)
vol_high_th = input.float(0.25, "vol high threshold", group=group_vol)
vol_crisis_th = input.float(0.50, "vol crisis threshold", group=group_vol)
vol_bucket = garch_vol < vol_low_th ? 1 : garch_vol < vol_high_th ? 2 : garch_vol < vol_crisis_th ? 3 : 4

// FIX #6: vol_of_vol and vol_cluster NaN protection
vol_of_vol = ta.stdev(ta.stdev(r, 20), 20)
vol_of_vol := na(vol_of_vol) ? 0.0 : vol_of_vol  // FIX

// FIX #1: vol_cluster NaN sanitization
vol_cluster_raw = ta.correlation(r * r, nz(r * r)[1], 20)
vol_cluster = na(vol_cluster_raw) ? 0.0 : vol_cluster_raw  // FIX

// ============================================================================
// CUSUM - VOLATILITY SCALED
// ============================================================================
var float cusum_pos = 0.0
var float cusum_neg = 0.0

k = cusum_k_mult * math.max(garch_vol, 1e-6)
drift = cusum_drift_mult * math.max(garch_vol, 1e-6)

ret_mean = ta.sma(r, 60)
ret_std = ta.stdev(r, 60)
ret_std := na(ret_std) or ret_std <= 0 ? 1e-6 : ret_std
z = (r - ret_mean) / ret_std
z := na(z) ? 0.0 : z  // FIX

cusum_pos := math.max(0.0, nz(cusum_pos[1]) + z - drift)
cusum_neg := math.max(0.0, nz(cusum_neg[1]) - z - drift)

cusum_detect_pos = cusum_pos > k
cusum_detect_neg = cusum_neg > k
cusum_detect = cusum_detect_pos or cusum_detect_neg

if cusum_detect and cusum_reset_on_detect
    cusum_pos := 0.0
    cusum_neg := 0.0

// ============================================================================
// REGIME PARAMETERS (TYPE DEFINITION)
// ============================================================================
type RegParams
    float vol_mu
    float vol_sigma
    float mom_mu
    float mom_sigma
    float trend_mu
    float trend_sigma
    float dd_mu
    float dd_sigma
    float volcluster_mu
    float volcluster_sigma

// FIX #3: SAFE GAUSSIAN LIKELIHOOD (NaN-PROTECTED)
gauss_like_safe(x, mu, sigma) =>
    xn = na(x) ? mu : x  // FIX: use mu if x is NaN
    s = math.max(sigma, 1e-6)
    exp_arg = -0.5 * math.pow((xn - mu) / s, 2)
    exp_arg := exp_arg < -20 ? -20 : exp_arg  // prevent underflow
    math.exp(exp_arg)

// Regime parameter templates
reg_params(reg) =>
    if reg == 1  // BULL
        RegParams.new(0.12, 0.06, 0.05, 0.05, 0.03, 0.02, 0.0, 0.05, 0.2, 0.1)
    else if reg == 2  // BEAR
        RegParams.new(0.25, 0.10, -0.06, 0.06, -0.04, 0.05, -0.10, 0.08, 0.4, 0.15)
    else if reg == 3  // HIGH VOL
        RegParams.new(0.35, 0.12, 0.0, 0.08, 0.0, 0.08, -0.05, 0.12, 0.5, 0.2)
    else if reg == 4  // LOW VOL
        RegParams.new(0.08, 0.04, 0.0, 0.03, 0.0, 0.03, -0.02, 0.03, 0.1, 0.05)
    else  // CRISIS
        RegParams.new(0.6, 0.25, -0.25, 0.2, -0.12, 0.12, -0.35, 0.2, 0.8, 0.3)

// Compute per-regime likelihood (NaN-SAFE)
likelihood_reg(reg) =>
    p = reg_params(reg)
    lv = gauss_like_safe(garch_vol, p.vol_mu, p.vol_sigma)
    lm = gauss_like_safe(mom_score, p.mom_mu, p.mom_sigma)
    lt = gauss_like_safe(trend_alignment, p.trend_mu, p.trend_sigma)
    ld = gauss_like_safe(drawdown, p.dd_mu, p.dd_sigma)
    lc = gauss_like_safe(vol_cluster, p.volcluster_mu, p.volcluster_sigma)
    lik = lv * lm * lt * ld * lc + 1e-12
    lik

L1 = likelihood_reg(1)
L2 = likelihood_reg(2)
L3 = likelihood_reg(3)
L4 = likelihood_reg(4)
L5 = likelihood_reg(5)

// ============================================================================
// BAYESIAN REGIME FILTER (FIXED REGIME SWITCHING)
// ============================================================================
var float p1 = 0.2
var float p2 = 0.2
var float p3 = 0.2
var float p4 = 0.2
var float p5 = 0.2

// Prior with inertia
mix = 1.0 - inertia
prior1 = p1 * inertia + mix * 0.2
prior2 = p2 * inertia + mix * 0.2
prior3 = p3 * inertia + mix * 0.2
prior4 = p4 * inertia + mix * 0.2
prior5 = p5 * inertia + mix * 0.2

// Posterior (unnormalized)
post1 = prior1 * L1
post2 = prior2 * L2
post3 = prior3 * L3
post4 = prior4 * L4
post5 = prior5 * L5

// Normalize (NaN-SAFE)
norm = post1 + post2 + post3 + post4 + post5
norm := norm <= 1e-15 ? 1e-12 : norm  // FIX: tighter floor
p1 := post1 / norm
p2 := post2 / norm
p3 := post3 / norm
p4 := post4 / norm
p5 := post5 / norm

// FIX: Sanitize probabilities (should never happen, but defensive)
p1 := na(p1) ? 0.2 : p1
p2 := na(p2) ? 0.2 : p2
p3 := na(p3) ? 0.2 : p3
p4 := na(p4) ? 0.2 : p4
p5 := na(p5) ? 0.2 : p5

// MAP regime
max_p = math.max(math.max(math.max(p1, p2), math.max(p3, p4)), p5)
regime_map = p1 == max_p ? 1 : p2 == max_p ? 2 : p3 == max_p ? 3 : p4 == max_p ? 4 : 5

// Entropy-based confidence
probs_arr = array.from(p1, p2, p3, p4, p5)
entropy = 0.0
for i = 0 to 4
    pr = array.get(probs_arr, i)
    if pr > 1e-12
        entropy := entropy - pr * math.log(pr)
max_entropy = math.log(5.0)
confidence = 1.0 - entropy / max_entropy

// FIX #4 & #7: REGIME SWITCHING LOGIC (FIXED BOTH prev_map AND CUSUM BUGS)
var int regime_dur = 0
var int current_regime = 1  // persistent

// Track duration of current MAP regime
if regime_map == current_regime
    regime_dur += 1
else
    // MAP has changed but we haven't switched yet
    regime_dur := 0  // reset duration counter

regime_stable = regime_dur >= min_switch_duration
force_switch = cusum_detect

// ✅ FIX #7: Regime switch decision (REMOVED regime_dur >= 1 BUG)
if force_switch
    // CUSUM forces immediate switch (even if regime_dur = 0)
    current_regime := regime_map
    regime_dur := min_switch_duration  // grant stability immediately
else if regime_map != current_regime and regime_stable
    // Stable switch allowed (only after stability period)
    current_regime := regime_map
// Note: regime_dur continues incrementing as long as regime_map == current_regime

// Uncertainty fallback
is_uncertain = confidence < confidence_threshold
final_regime = is_uncertain ? 0 : current_regime

// ============================================================================
// POSITION SIZING (REGIME-AWARE)
// ============================================================================
regime_multiplier(rid) =>
    switch rid
        1 => 1.2   // BULL
        2 => 0.5   // BEAR
        3 => 0.35  // HIGH VOL
        4 => 1.0   // LOW VOL
        5 => 0.15  // CRISIS
        => 0.35    // UNCERTAIN

base_mult = regime_multiplier(final_regime)
pos_mult = math.min(max_position_mult, math.max(min_position_mult, base_mult * (0.5 + 0.5 * confidence)))

if final_regime == 0
    pos_mult := pos_mult * uncertain_position_mult

// Regime permissions
allow_long_by_regime = (final_regime == 1 and allow_bull) or (final_regime == 4 and allow_lowv) or (final_regime == 3 and allow_highv)
allow_short_by_regime = (final_regime == 2 and allow_bear) or (final_regime == 3 and allow_highv) or (final_regime == 5 and allow_crisis)

can_long = allow_long_by_regime and not is_uncertain
can_short = allow_short_by_regime and not is_uncertain

// ✅ FIX #9: Trading mode controls (NEW FEATURE)
trading_mode = input.string("Both", "Trading Mode", options=["Long Only", "Short Only", "Both"], group="Trading")
use_regime_filter = input.bool(false, "Use Regime Filter", group="Trading")

// Mode filters
mode_allows_long = trading_mode == "Long Only" or trading_mode == "Both"
mode_allows_short = trading_mode == "Short Only" or trading_mode == "Both"

// Final permission (mode AND regime)
regime_ok_long = mode_allows_long and (not use_regime_filter or can_long)
regime_ok_short = mode_allows_short and (not use_regime_filter or can_short)

qty_pct = base_size_pct * pos_mult

// ============================================================================
// TRADING RULES (MIRRORBOT RSI-OF-RSI)
// ============================================================================
long_entry_cond = rsi2 < long_entry_val and regime_ok_long
long_close_cond = rsi2 > long_tp_val

short_entry_cond = rsi2 > short_entry_val and regime_ok_short
short_close_cond = rsi2 < short_tp_val

if long_entry_cond
    strategy.entry("Long", strategy.long, qty=qty_pct)
if long_close_cond
    strategy.close("Long")

if short_entry_cond
    strategy.entry("Short", strategy.short, qty=qty_pct)
if short_close_cond
    strategy.close("Short")

// ============================================================================
// SAFE AUTO-TUNING (BOUNDED WITH DECAY)
// ============================================================================
var float vol_low_ad = vol_low_th
var float vol_high_ad = vol_high_th
var float cusum_k_ad = cusum_k_mult
var float cusum_drift_ad = cusum_drift_mult

var int trades_tracked = 0
var float cum_net = 0.0
var int wins = 0
var int losses = 0

if strategy.closedtrades > trades_tracked
    last_net = strategy.netprofit - cum_net
    cum_net := strategy.netprofit
    trades_tracked += 1
    if last_net > 0
        wins += 1
    else
        losses += 1

win_rate = (wins + losses) > 0 ? wins / (wins + losses) : 0.0
avg_pnl_recent = trades_tracked > 0 ? cum_net / trades_tracked : 0.0

if enable_auto_tune and trades_tracked > 5
    if win_rate < 0.45 or avg_pnl_recent < 0
        // Tighten
        vol_low_ad := vol_low_ad * (1 + tune_aggressiveness)
        vol_high_ad := vol_high_ad * (1 + tune_aggressiveness)
        cusum_k_ad := cusum_k_ad * (1 + tune_aggressiveness * 0.5)
    else if win_rate > 0.55 and avg_pnl_recent > 0
        // Relax
        vol_low_ad := vol_low_ad * (1 - tune_aggressiveness * 0.5)
        vol_high_ad := vol_high_ad * (1 - tune_aggressiveness * 0.5)
        cusum_k_ad := cusum_k_ad * (1 - tune_aggressiveness * 0.25)

// Decay toward base
vol_low_ad := vol_low_ad * tune_decay + vol_low_th * (1 - tune_decay)
vol_high_ad := vol_high_ad * tune_decay + vol_high_th * (1 - tune_decay)
cusum_k_ad := cusum_k_ad * tune_decay + cusum_k_mult * (1 - tune_decay)

// ============================================================================
// DISPLAY & DIAGNOSTICS
// ============================================================================
regime_name = final_regime == 0 ? "UNCERTAIN" : final_regime == 1 ? "BULL" : final_regime == 2 ? "BEAR" : final_regime == 3 ? "HIGH VOL" : final_regime == 4 ? "LOW VOL" : "CRISIS"

regime_color = final_regime == 0 ? color.new(color.gray, 85) : final_regime == 1 ? color.new(color.green, 85) : final_regime == 2 ? color.new(color.red, 85) : final_regime == 3 ? color.new(color.orange, 85) : final_regime == 4 ? color.new(color.blue, 85) : color.new(color.purple, 85)

bgcolor(show_bg ? regime_color : na)

plot(rsi2, color=color.white, linewidth=2, title="RSI of RSI")
hline(long_entry_val, "LEntry", color=color.new(color.green, 70))
hline(short_entry_val, "SEntry", color=color.new(color.red, 70))

// Info table
if show_table and barstate.islast
    var table t = table.new(position.top_right, 2, 20, border_width=1)
    table.cell(t, 0, 0, "MB Power V2", bgcolor=color.new(color.gray, 80), text_color=color.white)
    table.merge_cells(t, 0, 0, 1, 0)

    // ✅ FIX #9: Trading Mode row added
    table.cell(t, 0, 1, "Trading Mode", bgcolor=color.new(color.gray, 90))
    mode_color = trading_mode == "Long Only" ? color.green : trading_mode == "Short Only" ? color.red : color.blue
    table.cell(t, 1, 1, trading_mode, text_color=mode_color)

    table.cell(t, 0, 2, "Regime", bgcolor=color.new(color.gray, 90))
    regime_color_solid = final_regime == 0 ? color.gray : final_regime == 1 ? color.green : final_regime == 2 ? color.red : final_regime == 3 ? color.orange : final_regime == 4 ? color.blue : color.purple
    table.cell(t, 1, 2, regime_name, bgcolor=color.new(regime_color_solid, 80), text_color=color.white)

    table.cell(t, 0, 3, "Confidence", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 3, str.tostring(confidence * 100, "#.0") + "%")

    table.cell(t, 0, 4, "GARCH Vol", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 4, str.tostring(garch_vol * 100, "#.2") + "%")

    table.cell(t, 0, 5, "CUSUM", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 5, cusum_detect ? "YES" : "NO", text_color=cusum_detect ? color.red : color.gray)

    table.cell(t, 0, 6, "Pos Mult", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 6, str.tostring(pos_mult, "#.2"))

    table.cell(t, 0, 7, "Qty %", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 7, str.tostring(qty_pct, "#.1") + "%")

    table.cell(t, 0, 8, "WinRate", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 8, str.tostring(win_rate * 100, "#.0") + "%")

    table.cell(t, 0, 9, "MAP Regime", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 9, str.tostring(regime_map))

    table.cell(t, 0, 10, "Regime Dur", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 10, str.tostring(regime_dur))

    table.cell(t, 0, 11, "Probabilities", bgcolor=color.new(color.gray, 70), text_color=color.white)
    table.merge_cells(t, 0, 11, 1, 11)

    table.cell(t, 0, 12, "p1 (BULL)", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 12, str.tostring(p1 * 100, "#.1") + "%", bgcolor=color.new(color.green, 90))

    table.cell(t, 0, 13, "p2 (BEAR)", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 13, str.tostring(p2 * 100, "#.1") + "%", bgcolor=color.new(color.red, 90))

    table.cell(t, 0, 14, "p3 (H-VOL)", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 14, str.tostring(p3 * 100, "#.1") + "%", bgcolor=color.new(color.orange, 90))

    table.cell(t, 0, 15, "p4 (L-VOL)", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 15, str.tostring(p4 * 100, "#.1") + "%", bgcolor=color.new(color.blue, 90))

    table.cell(t, 0, 16, "p5 (CRISIS)", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 16, str.tostring(p5 * 100, "#.1") + "%", bgcolor=color.new(color.purple, 90))

    table.cell(t, 0, 17, "Filter", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 17, use_regime_filter ? "ON" : "OFF", text_color=use_regime_filter ? color.orange : color.green)

    table.cell(t, 0, 18, "Net P&L", bgcolor=color.new(color.gray, 90))
    pnl_color = strategy.netprofit > 0 ? color.green : color.red
    table.cell(t, 1, 18, str.tostring(strategy.netprofit, "#,###"), text_color=pnl_color)

// ============================================================================
// ✅ FIX #8: ALERTS (Using alert() for strategies, not alertcondition())
// ============================================================================
if long_entry_cond
    alert("MB Power V2: Long Entry - RSI2=" + str.tostring(rsi2, "#.1") + " Regime=" + regime_name, alert.freq_once_per_bar_close)

if short_entry_cond
    alert("MB Power V2: Short Entry - RSI2=" + str.tostring(rsi2, "#.1") + " Regime=" + regime_name, alert.freq_once_per_bar_close)

if cusum_detect
    alert("MB Power V2: CUSUM change-point detected - Volatility regime shift", alert.freq_once_per_bar_close)

if final_regime != final_regime[1]
    alert("MB Power V2: Regime changed to " + regime_name + " (confidence=" + str.tostring(confidence * 100, "#.0") + "%)", alert.freq_once_per_bar_close)

// ============================================================================
// END - POWER EDITION V2 - PRODUCTION READY (ALL FIXES APPLIED)
// ============================================================================
