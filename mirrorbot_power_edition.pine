// @version=5
strategy("MirrorBot — Power Edition (Bayesian Regime + GARCH + Safe Auto-Tune)",
  shorttitle="MirrorBot Pro",
  overlay=true,
  initial_capital=100000,
  default_qty_type=strategy.percent_of_equity,
  default_qty_value=100,
  commission_type=strategy.commission.percent,
  commission_value=0.075,
  slippage=1)

// ==============================
// USER INPUTS - TUNABLE
// ==============================
group_vol = "Volatility & GARCH"
garch_omega   = input.float(1e-6, "GARCH ω (omega)", group=group_vol, step=1e-6)
garch_alpha   = input.float(0.12, "GARCH α (alpha)", group=group_vol, step=0.01)
garch_beta    = input.float(0.82, "GARCH β (beta)", group=group_vol, step=0.01)
garch_init_lb = input.int(50, "GARCH init lookback (obs)", group=group_vol, minval=10)

group_cusum = "CUSUM / Change-point"
cusum_k_mult = input.float(3.0, "CUSUM threshold multiplier (k)", group=group_cusum)
cusum_drift_mult = input.float(0.15, "CUSUM drift multiplier", group=group_cusum)
cusum_reset_on_detect = input.bool(true, "Reset CUSUM on detect", group=group_cusum)

group_bayes = "Bayesian Regime Filter"
inertia = input.float(0.90, "State Inertia (0-1) - higher = stickier", group=group_bayes, step=0.01)
min_switch_duration = input.int(3, "Min Regime Duration (bars)", group=group_bayes, minval=1)
confidence_threshold = input.float(0.60, "Confidence Threshold (fallback)", group=group_bayes, step=0.01)
uncertain_position_mult = input.float(0.25, "Position Multiplier in UNCERTAIN", group=group_bayes, step=0.01)

group_tune = "Auto-Tune (Safe)"
enable_auto_tune = input.bool(true, "Enable auto-tune (safe)", group=group_tune)
tune_aggressiveness = input.float(0.03, "Aggressiveness (blend rate)", group=group_tune, step=0.01)
tune_decay = input.float(0.98, "Decay (snap-back) factor", group=group_tune, step=0.001)

group_entries = "Entries & MirrorBot"
magic_rsi_period = input.int(9, "RSI period", group=group_entries, minval=2)
magic_rsi2_period = input.int(144, "RSI-of-RSI period", group=group_entries, minval=10)
long_entry_val = input.float(49.9, "Long Entry threshold (RSI2)", group=group_entries)
long_tp_val    = input.float(50.0, "Long TP threshold (RSI2)", group=group_entries)
short_entry_val = input.float(50.1, "Short Entry threshold (RSI2)", group=group_entries)
short_tp_val    = input.float(50.0, "Short TP threshold (RSI2)", group=group_entries)

group_risk = "Position Sizing"
base_size_pct = input.float(100.0, "Base position (% equity)", group=group_risk)
max_position_mult = input.float(1.5, "Max Regime Multiplier", group=group_risk)
min_position_mult = input.float(0.1, "Min Regime Multiplier", group=group_risk)

// Regime permission toggles
allow_bull   = input.bool(true, "Allow trading in BULL", group="Regime Permissions")
allow_bear   = input.bool(true, "Allow trading in BEAR", group="Regime Permissions")
allow_highv  = input.bool(true, "Allow trading in HIGH VOL", group="Regime Permissions")
allow_lowv   = input.bool(true, "Allow trading in LOW VOL", group="Regime Permissions")
allow_crisis = input.bool(false, "Allow trading in CRISIS", group="Regime Permissions")

// Display
show_table   = input.bool(true, "Show info table", group="Display")
show_bg      = input.bool(true, "Show regime background", group="Display")

// ==============================
// BASIC FEATURES
// ==============================
src = hlc3
r = math.log(close / close[1])  // log-return (safer)
r_na = na(r) ? 0.0 : r

// RSI-of-RSI entry logic
rsi1 = ta.rsi(src, magic_rsi_period)
rsi2 = ta.rsi(rsi1, magic_rsi2_period)

// Momentum & trend features
mom_fast = ta.roc(close, 10)
mom_med  = ta.roc(close, 20)
mom_slow = ta.roc(close, 60)
mom_score = (mom_fast + mom_med + mom_slow) / 3.0
ema_fast = ta.ema(close, 20)
ema_slow = ta.ema(close, 50)
trend_alignment = (ema_fast - ema_slow) / ema_slow

// Volume factor and microstructure
vol_ma = ta.sma(volume, 20)
volume_factor = na(vol_ma) or vol_ma == 0 ? 0.0 : math.log(volume / vol_ma)
range_exp = (high - low) / close
range_ma = ta.sma(range_exp, 20)
micro_sig = na(range_ma) or range_ma==0 ? 0.0 : (range_exp / range_ma - 1.0)

// drawdown
var float running_max = na
running_max := na(running_max) ? close : math.max(running_max, close)
drawdown = (close - running_max) / running_max

// realized vol: short-term lookbacks (for adaptive scaling)
realized_vol_short = ta.stdev(r, 10) * math.sqrt(252)
realized_vol_med   = ta.stdev(r, 20) * math.sqrt(252)
realized_vol_long  = ta.stdev(r, 60) * math.sqrt(252)

// ==============================
// GARCH(1,1) - Recursive Variance (persistent var)
// ==============================
var float cond_var = na
// initialize cond_var once enough lookbacks exist
init_var = ta.variance(r, garch_init_lb)
cond_var := na(cond_var) and not na(init_var) ? init_var : cond_var

// compute squared return with small floor
r2 = r_na * r_na
omega = garch_omega
alpha = garch_alpha
beta  = garch_beta
// ensure stationarity
if alpha + beta >= 0.999
    // slightly nudge beta down to keep stability
    beta := 0.98 - alpha

// recursive update (safe with var)
cond_var := nz(omega) + nz(alpha) * nz(r2[1]) + nz(beta) * nz(cond_var[1])
cond_var := math.max(cond_var, 1e-12)
garch_vol = math.sqrt(cond_var) * math.sqrt(252)  // annualized

// vol regime buckets for emissions
vol_low_th  = input.float(0.10, "vol low threshold (annual)", group=group_vol)
vol_high_th = input.float(0.25, "vol high threshold (annual)", group=group_vol)
vol_crisis_th = input.float(0.50, "vol crisis threshold (annual)", group=group_vol)
vol_bucket = garch_vol < vol_low_th ? 1 : garch_vol < vol_high_th ? 2 : garch_vol < vol_crisis_th ? 3 : 4

// vol-of-vol
vol_of_vol = ta.stdev(ta.stdev(r, 20), 20)

// volatility clustering (autocorrelation of squared returns)
vol_cluster = ta.correlation(r * r, nz(r * r)[1], 20)

// ==============================
// CUSUM - volatility scaled, dynamic drift & fast reset
// ==============================
var float cusum_pos = 0.0
var float cusum_neg = 0.0

// adaptive threshold scaled to current vol
k = cusum_k_mult * math.max(garch_vol, 1e-6)  // threshold
drift = cusum_drift_mult * math.max(garch_vol, 1e-6)

// compute z-like standardized return w.r.t rolling stats
ret_mean = ta.sma(r, 60)
ret_std  = ta.stdev(r, 60)
ret_std := na(ret_std) or ret_std <= 0 ? 1e-6 : ret_std
z = (r - ret_mean) / ret_std

// update
cusum_pos := math.max(0.0, nz(cusum_pos[1]) + z - drift)
cusum_neg := math.max(0.0, nz(cusum_neg[1]) - z - drift)

// detect
cusum_detect_pos = cusum_pos > k
cusum_detect_neg = cusum_neg > k
cusum_detect = cusum_detect_pos or cusum_detect_neg

if cusum_detect and cusum_reset_on_detect
    cusum_pos := 0.0
    cusum_neg := 0.0

// ==============================
// EMISSION LIKELIHOODS - multi-feature Gaussian-style scoring
// ==============================
// We define 5 regimes: 1=BULL, 2=BEAR, 3=HIGH VOL, 4=LOW VOL, 5=CRISIS
// For each regime define expected feature centers and sigmas (tunable)
// Keep centers conservative; auto-tune will adjust slowly.

// FIXED: Type definition syntax for PineScript v5
type RegParams
    float vol_mu
    float vol_sigma
    float mom_mu
    float mom_sigma
    float trend_mu
    float trend_sigma
    float dd_mu
    float dd_sigma
    float volcluster_mu
    float volcluster_sigma

// helper: gaussian-like likelihood (unnormalized)
gauss_like(x, mu, sigma) =>
    s = math.max(sigma, 1e-6)
    math.exp(-0.5 * math.pow((x - mu) / s, 2))

// base regime parameter templates (can be adapted by tuning)
reg_params(reg) =>
    // default params (educated priors)
    // BULL
    if reg == 1
        RegParams.new(0.12, 0.06, 0.05, 0.05, 0.03, 0.02, 0.0, 0.05, 0.2, 0.1)
    // BEAR
    else if reg == 2
        RegParams.new(0.25, 0.10, -0.06, 0.06, -0.04, 0.05, -0.10, 0.08, 0.4, 0.15)
    // HIGH VOL (volatile, mixed direction)
    else if reg == 3
        RegParams.new(0.35, 0.12, 0.0, 0.08, 0.0, 0.08, -0.05, 0.12, 0.5, 0.2)
    // LOW VOL (calm)
    else if reg == 4
        RegParams.new(0.08, 0.04, 0.0, 0.03, 0.0, 0.03, -0.02, 0.03, 0.1, 0.05)
    // CRISIS
    else
        RegParams.new(0.6, 0.25, -0.25, 0.2, -0.12, 0.12, -0.35, 0.2, 0.8, 0.3)

// compute per-regime likelihood using multiple features
likelihood_reg(reg) =>
    p = reg_params(reg)
    lv = gauss_like(garch_vol, p.vol_mu, p.vol_sigma)
    lm = gauss_like(mom_score, p.mom_mu, p.mom_sigma)
    lt = gauss_like(trend_alignment, p.trend_mu, p.trend_sigma)
    ld = gauss_like(drawdown, p.dd_mu, p.dd_sigma)
    lc = gauss_like(vol_cluster, p.volcluster_mu, p.volcluster_sigma)
    // combine (product) and small floor
    lik = lv * lm * lt * ld * lc + 1e-12
    lik

// compute likelihood vector
L1 = likelihood_reg(1)
L2 = likelihood_reg(2)
L3 = likelihood_reg(3)
L4 = likelihood_reg(4)
L5 = likelihood_reg(5)

// ==============================
// BAYESIAN REGIME FILTER - online update with inertia
// ==============================
var float p1 = 0.2
var float p2 = 0.2
var float p3 = 0.2
var float p4 = 0.2
var float p5 = 0.2

// build prior via inertia (stickiness) and mild uniform mixing
mix = 1.0 - inertia
prior1 = p1 * inertia + mix * 0.2
prior2 = p2 * inertia + mix * 0.2
prior3 = p3 * inertia + mix * 0.2
prior4 = p4 * inertia + mix * 0.2
prior5 = p5 * inertia + mix * 0.2

// apply likelihood -> posterior (unnormalized)
post1 = prior1 * L1
post2 = prior2 * L2
post3 = prior3 * L3
post4 = prior4 * L4
post5 = prior5 * L5

// normalize
norm = post1 + post2 + post3 + post4 + post5
norm := norm == 0 ? 1e-12 : norm
p1 := post1 / norm
p2 := post2 / norm
p3 := post3 / norm
p4 := post4 / norm
p5 := post5 / norm

// compute MAP regime and confidence (entropy based)
probs_arr = array.from(p1, p2, p3, p4, p5)
max_p = math.max(math.max(math.max(p1, p2), math.max(p3, p4)), p5)
regime_map = p1 == max_p ? 1 : p2 == max_p ? 2 : p3 == max_p ? 3 : p4 == max_p ? 4 : 5

// entropy
entropy = 0.0
for i = 0 to 4
    pr = array.get(probs_arr, i)
    if pr > 1e-12
        entropy := entropy - pr * math.log(pr)
max_entropy = math.log(5.0)
confidence = 1.0 - entropy / max_entropy  // 0..1

// regime stability estimate (duration)
var int regime_dur = 0
var int prev_map = 1
if regime_map == prev_map
    regime_dur += 1
else
    regime_dur := 1
prev_map := regime_map

regime_stable = regime_dur >= min_switch_duration

// final regime: respect min duration and cusp change signals
force_switch = cusum_detect  // change-point forces regime update
var int current_regime = 1
if force_switch and regime_dur >= 1
    // allow switch immediately on strong CUSUM
    current_regime := regime_map
else
    // if new MAP and stable condition met, switch
    if regime_map != prev_map and regime_stable
        current_regime := regime_map

// fallback meta-regime on low confidence
is_uncertain = confidence < confidence_threshold

final_regime = is_uncertain ? 0 : current_regime  // 0 = UNCERTAIN

// ==============================
// POSITION SIZING (regime-aware, confidence-weighted)
// ==============================
regime_multiplier(rid) =>
    // set base multipliers per regime
    switch rid
        1 => 1.2   // bull
        2 => 0.5   // bear
        3 => 0.35  // high vol
        4 => 1.0   // low vol
        5 => 0.15  // crisis
        => 0.25     // uncertain fallback

// compute blended multiplier with confidence
base_mult = final_regime == 0 ? regime_multiplier(0) : regime_multiplier(final_regime)
pos_mult = math.min(max_position_mult, math.max(min_position_mult, base_mult * (0.5 + 0.5 * confidence)))

// clamp smaller in UNCERTAIN
if final_regime == 0
    pos_mult := pos_mult * uncertain_position_mult

// allow/disallow trading by regime permissions
allow_long_by_regime = (final_regime == 1 and allow_bull) or (final_regime == 4 and allow_lowv) or (final_regime == 3 and allow_highv)
allow_short_by_regime = (final_regime == 2 and allow_bear) or (final_regime == 3 and allow_highv) or (final_regime == 5 and allow_crisis)

can_long = allow_long_by_regime and not is_uncertain
can_short = allow_short_by_regime and not is_uncertain

// final allowable if user doesn't want regime filter, keep simple toggle
use_regime_filter = input.bool(false, "Use Regime Filter (toggle)", group="Trading")
regime_ok_long = not use_regime_filter ? true : can_long
regime_ok_short = not use_regime_filter ? true : can_short

// compute order size
qty_pct = base_size_pct * pos_mult

// ==============================
// TRADING RULES (MirrorBot RSI-of-RSI entries)
// ==============================
long_entry_cond = rsi2 < long_entry_val and regime_ok_long
long_close_cond = rsi2 > long_tp_val

short_entry_cond = rsi2 > short_entry_val and regime_ok_short
short_close_cond = rsi2 < short_tp_val

// Execute trades (no pyramiding)
if long_entry_cond
    strategy.entry("Long", strategy.long, qty=qty_pct)
if long_close_cond
    strategy.close("Long")

if short_entry_cond
    strategy.entry("Short", strategy.short, qty=qty_pct)
if short_close_cond
    strategy.close("Short")

// ==============================
// SAFE AUTO-TUNING (decay toward base)
// ==============================
// We keep only a very small, conservative adaptive tweak: adjust vol thresholds and CUSUM multiplier slightly
var float vol_low_ad = vol_low_th
var float vol_high_ad = vol_high_th
var float cusum_k_ad = cusum_k_mult
var float cusum_drift_ad = cusum_drift_mult

// compute simple performance metric (win rate + avg pnl sign)
var int trades_tracked = 0
var float cum_net = 0.0
var int wins = 0
var int losses = 0
// update when new closed trade occurs
if strategy.closedtrades > trades_tracked
    last_net = strategy.netprofit - cum_net
    cum_net := strategy.netprofit
    trades_tracked += 1
    if last_net > 0
        wins += 1
    else
        losses += 1

win_rate = (wins + losses) > 0 ? wins / (wins + losses) : 0.0
avg_pnl_recent = trades_tracked > 0 ? cum_net / trades_tracked : 0.0

if enable_auto_tune and trades_tracked > 5
    // conservative rules: nudge thresholds toward safer values if performance bad, else slowly relax
    if win_rate < 0.45 or avg_pnl_recent < 0
        // tighten: make regime detection more conservative
        vol_low_ad := vol_low_ad * (1 + tune_aggressiveness)
        vol_high_ad := vol_high_ad * (1 + tune_aggressiveness)
        cusum_k_ad := cusum_k_ad * (1 + tune_aggressiveness * 0.5)
        cusum_drift_ad := cusum_drift_ad * (1 + tune_aggressiveness * 0.3)
    else if win_rate > 0.55 and avg_pnl_recent > 0
        // relax slightly
        vol_low_ad := vol_low_ad * (1 - tune_aggressiveness * 0.5)
        vol_high_ad := vol_high_ad * (1 - tune_aggressiveness * 0.5)
        cusum_k_ad := cusum_k_ad * (1 - tune_aggressiveness * 0.25)
        cusum_drift_ad := cusum_drift_ad * (1 - tune_aggressiveness * 0.2)

// decay back toward base
vol_low_ad := vol_low_ad * tune_decay + vol_low_th * (1 - tune_decay)
vol_high_ad := vol_high_ad * tune_decay + vol_high_th * (1 - tune_decay)
cusum_k_ad := cusum_k_ad * tune_decay + cusum_k_mult * (1 - tune_decay)
cusum_drift_ad := cusum_drift_ad * tune_decay + cusum_drift_mult * (1 - tune_decay)

// apply adapted thresholds to display (internals still based on garch_vol and cusum vars above)
// NOTE: We keep core math stable; auto-tune only nudges display/position thresholds conservatively

// ==============================
// DISPLAY & DIAGNOSTICS
// ==============================
regime_color = final_regime == 0 ? color.gray : final_regime == 1 ? color.new(color.green, 85) : final_regime == 2 ? color.new(color.red, 85) : final_regime == 3 ? color.new(color.orange, 85) : final_regime == 4 ? color.new(color.blue, 85) : color.new(color.purple, 85)
if show_bg
    bgcolor(regime_color)

plotshape(series=final_regime == 1 ? 1 : na, title="Bull Regime", location=location.top, color=color.green, style=shape.labelup, text="BULL")
plotshape(series=final_regime == 2 ? 1 : na, title="Bear Regime", location=location.top, color=color.red, style=shape.labeldown, text="BEAR")
plotshape(series=final_regime == 3 ? 1 : na, title="HighVol", location=location.top, color=color.orange, style=shape.triangleup, text="H-VOL")
plotshape(series=final_regime == 4 ? 1 : na, title="LowVol", location=location.top, color=color.blue, style=shape.triangleup, text="L-VOL")
plotshape(series=final_regime == 5 ? 1 : na, title="Crisis", location=location.top, color=color.purple, style=shape.xcross, text="CRISIS")
plotshape(series=final_regime == 0 ? 1 : na, title="UNCERTAIN", location=location.top, color=color.gray, style=shape.circle, text="UNC")

plot(rsi2, color=color.white, linewidth=2, title="RSI of RSI")
hline(long_entry_val, "LEntry", color=color.new(color.green, 70))
hline(long_tp_val, "LTP", color=color.new(color.green, 60))
hline(short_entry_val, "SEntry", color=color.new(color.red, 70))
hline(short_tp_val, "STP", color=color.new(color.red, 60))

// info table
if show_table and barstate.islast
    var table t = table.new(position.top_right, 2, 16, border_width=1)
    table.cell(t, 0, 0, "MirrorBot Pro", bgcolor=color.new(color.gray, 80), text_color=color.white)
    table.merge_cells(t, 0, 0, 1, 0)
    table.cell(t, 0, 1, "Regime", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 1, final_regime == 0 ? "UNCERTAIN" : final_regime == 1 ? "BULL" : final_regime == 2 ? "BEAR" : final_regime == 3 ? "HIGH VOL" : final_regime == 4 ? "LOW VOL" : "CRISIS")
    table.cell(t, 0, 2, "Confidence", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 2, str.tostring(confidence * 100, "#.0") + "%")
    table.cell(t, 0, 3, "GARCH Vol", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 3, str.tostring(garch_vol * 100, "#.2") + "%")
    table.cell(t, 0, 4, "CUSUM Detected", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 4, cusum_detect ? "YES" : "NO", text_color=cusum_detect ? color.red : color.gray)
    table.cell(t, 0, 5, "Pos Mult", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 5, str.tostring(pos_mult, "#.2"))
    table.cell(t, 0, 6, "Qty %", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 6, str.tostring(qty_pct, "#.1") + "%")
    table.cell(t, 0, 7, "WinRate", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 7, str.tostring(win_rate * 100, "#.0") + "%")
    table.cell(t, 0, 8, "Avg P&L", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 8, str.tostring(avg_pnl_recent, "#.2"))
    table.cell(t, 0, 9, "p1", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 9, str.tostring(p1 * 100, "#.0") + "%")
    table.cell(t, 0, 10, "p2", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 10, str.tostring(p2 * 100, "#.0") + "%")
    table.cell(t, 0, 11, "p3", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 11, str.tostring(p3 * 100, "#.0") + "%")
    table.cell(t, 0, 12, "p4", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 12, str.tostring(p4 * 100, "#.0") + "%")
    table.cell(t, 0, 13, "p5", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 13, str.tostring(p5 * 100, "#.0") + "%")
    table.cell(t, 0, 14, "MAP Regime", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 14, str.tostring(regime_map))
    table.cell(t, 0, 15, "Reg Dur", bgcolor=color.new(color.gray, 90))
    table.cell(t, 1, 15, str.tostring(regime_dur))

// ==============================
// ALERTS
// ==============================
alertcondition(long_entry_cond, title="MirrorBot Pro Long Entry", message="MirrorBot Pro: Long Entry conditions met")
alertcondition(short_entry_cond, title="MirrorBot Pro Short Entry", message="MirrorBot Pro: Short Entry conditions met")
alertcondition(cusum_detect, title="CUSUM Change Point", message="CUSUM detected potential change")
alertcondition(is_uncertain, title="MirrorBot UNCERTAIN", message="MirrorBot Pro: Low confidence — UNCERTAIN regime")

// ==============================
// END
// ==============================
